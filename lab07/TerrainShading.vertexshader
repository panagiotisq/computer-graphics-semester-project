#version 330 core

layout (location = 0) in vec3 aPos;  // Vertex position modelspace
layout (location = 1) in vec2 aTexCoord; // Texture coordinates
layout (location = 2) in vec2 aTexCoord2;
layout (location = 3) in vec3 aNormal; // Vertex normal modelspace

out float Height;
out vec4 Positionc; // Vertex position cameraspace
out vec4 Positionw; // Vertex position worldspace
out vec2 TexCoord;
out vec2 TexCoord2;
out vec4 Normalc; // Vertex normal cameraspace
out vec4 Normalw; // Vertex normal worldspace
out vec4 lightDirectionc;
out vec4 lightDirectionw;
out vec3 posModelspace;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform vec3 lightDirection;

uniform int rotationalDistortion;
uniform int voxelising; 
uniform float rottime;
uniform float time;

float theta;
float d = 920/2.0f ; // max z (920 is the dimension of the world in z axis)
float w = 1222/2.0f ; // max x
vec3 pos_after_Rot(vec3 pos, float theta);
float r;
vec3 newPos;

float xo,yo,zo;
float gridSize = 3.0;  // Size of each voxel
float gap = 1.0;// * time;  

void main()
{
    Height = aPos.y;
    TexCoord = aTexCoord;
    TexCoord2 = aTexCoord2;
    theta = 0.5*rottime;
    
    newPos = aPos;

    // voxelising
    
    if (voxelising!=0){
        
        newPos.x = floor(aPos.x / gridSize) * gridSize;
        newPos.y = floor(aPos.y / gridSize) * gridSize;
        newPos.z = floor(aPos.z / gridSize) * gridSize;
        if (voxelising==3){
            vec3 voxelIndex = floor(aPos / gridSize); // calculates the grid index
            newPos = aPos + voxelIndex * gap; 
        }
    }
    
    posModelspace = newPos;

    if (rotationalDistortion==1){
        newPos = pos_after_Rot( aPos , theta);
    }

    gl_Position = projection * view * model * vec4(newPos, 1.0);

    Positionc = view * model * vec4(newPos, 1.0);
    Positionw =  model * vec4(newPos, 1.0);

    Normalc = view * model * vec4(aNormal, 0);
    Normalw =  model * vec4(aNormal, 0);

    lightDirectionc =   view * vec4(normalize(lightDirection),0) ;
    lightDirectionw = vec4(normalize(lightDirection),0);
}


vec3 pos_after_Rot(vec3 pos, float theta){
    
    vec3 newpos;

    float xfactor = (pos.x+w)/1222.0f ; // because i want the bending to be more rapid as x increases
    float zo = pos.z;
    float yo = pos.y;
    //theta = xfactor * theta; // this way the points with the smallest x values dont bend at all
    theta = theta - 0.8*xfactor * theta; // this way all the points follow the rotation
    float r = d/theta;

    float theta1 = zo/r;

    newpos.x = pos.x;
    newpos.y = r - r*cos(theta1) + yo*cos(theta1);
    newpos.z = r*sin(theta1) - yo*sin(theta1);

    return newpos;


}